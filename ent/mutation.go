// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"go-api-template/ent/invoice"
	"go-api-template/ent/job"
	"go-api-template/ent/jobapplication"
	"go-api-template/ent/predicate"
	"go-api-template/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeInvoice        = "Invoice"
	TypeJob            = "Job"
	TypeJobApplication = "JobApplication"
	TypeUser           = "User"
)

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	value              *float64
	addvalue           *float64
	state              *invoice.State
	interval_number    *int
	addinterval_number *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	job                *uuid.UUID
	clearedjob         bool
	done               bool
	oldValue           func(context.Context) (*Invoice, error)
	predicates         []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id uuid.UUID) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invoice entities.
func (m *InvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *InvoiceMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *InvoiceMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *InvoiceMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *InvoiceMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *InvoiceMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetState sets the "state" field.
func (m *InvoiceMutation) SetState(i invoice.State) {
	m.state = &i
}

// State returns the value of the "state" field in the mutation.
func (m *InvoiceMutation) State() (r invoice.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldState(ctx context.Context) (v invoice.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *InvoiceMutation) ResetState() {
	m.state = nil
}

// SetJobID sets the "job_id" field.
func (m *InvoiceMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *InvoiceMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *InvoiceMutation) ResetJobID() {
	m.job = nil
}

// SetIntervalNumber sets the "interval_number" field.
func (m *InvoiceMutation) SetIntervalNumber(i int) {
	m.interval_number = &i
	m.addinterval_number = nil
}

// IntervalNumber returns the value of the "interval_number" field in the mutation.
func (m *InvoiceMutation) IntervalNumber() (r int, exists bool) {
	v := m.interval_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalNumber returns the old "interval_number" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldIntervalNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalNumber: %w", err)
	}
	return oldValue.IntervalNumber, nil
}

// AddIntervalNumber adds i to the "interval_number" field.
func (m *InvoiceMutation) AddIntervalNumber(i int) {
	if m.addinterval_number != nil {
		*m.addinterval_number += i
	} else {
		m.addinterval_number = &i
	}
}

// AddedIntervalNumber returns the value that was added to the "interval_number" field in this mutation.
func (m *InvoiceMutation) AddedIntervalNumber() (r int, exists bool) {
	v := m.addinterval_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntervalNumber resets all changes to the "interval_number" field.
func (m *InvoiceMutation) ResetIntervalNumber() {
	m.interval_number = nil
	m.addinterval_number = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the Job entity.
func (m *InvoiceMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[invoice.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *InvoiceMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *InvoiceMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.value != nil {
		fields = append(fields, invoice.FieldValue)
	}
	if m.state != nil {
		fields = append(fields, invoice.FieldState)
	}
	if m.job != nil {
		fields = append(fields, invoice.FieldJobID)
	}
	if m.interval_number != nil {
		fields = append(fields, invoice.FieldIntervalNumber)
	}
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldValue:
		return m.Value()
	case invoice.FieldState:
		return m.State()
	case invoice.FieldJobID:
		return m.JobID()
	case invoice.FieldIntervalNumber:
		return m.IntervalNumber()
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	case invoice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldValue:
		return m.OldValue(ctx)
	case invoice.FieldState:
		return m.OldState(ctx)
	case invoice.FieldJobID:
		return m.OldJobID(ctx)
	case invoice.FieldIntervalNumber:
		return m.OldIntervalNumber(ctx)
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case invoice.FieldState:
		v, ok := value.(invoice.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case invoice.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case invoice.FieldIntervalNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalNumber(v)
		return nil
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, invoice.FieldValue)
	}
	if m.addinterval_number != nil {
		fields = append(fields, invoice.FieldIntervalNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldValue:
		return m.AddedValue()
	case invoice.FieldIntervalNumber:
		return m.AddedIntervalNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case invoice.FieldIntervalNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntervalNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldValue:
		m.ResetValue()
		return nil
	case invoice.FieldState:
		m.ResetState()
		return nil
	case invoice.FieldJobID:
		m.ResetJobID()
		return nil
	case invoice.FieldIntervalNumber:
		m.ResetIntervalNumber()
		return nil
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, invoice.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, invoice.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	rate                *float64
	addrate             *float64
	duration            *int
	addduration         *int
	state               *job.State
	invoice_interval    *int
	addinvoice_interval *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	employer            *uuid.UUID
	clearedemployer     bool
	contractor          *uuid.UUID
	clearedcontractor   bool
	invoices            map[uuid.UUID]struct{}
	removedinvoices     map[uuid.UUID]struct{}
	clearedinvoices     bool
	applications        map[uuid.UUID]struct{}
	removedapplications map[uuid.UUID]struct{}
	clearedapplications bool
	done                bool
	oldValue            func(context.Context) (*Job, error)
	predicates          []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id uuid.UUID) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRate sets the "rate" field.
func (m *JobMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *JobMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *JobMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *JobMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *JobMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetDuration sets the "duration" field.
func (m *JobMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *JobMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *JobMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *JobMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *JobMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetEmployerID sets the "employer_id" field.
func (m *JobMutation) SetEmployerID(u uuid.UUID) {
	m.employer = &u
}

// EmployerID returns the value of the "employer_id" field in the mutation.
func (m *JobMutation) EmployerID() (r uuid.UUID, exists bool) {
	v := m.employer
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployerID returns the old "employer_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldEmployerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployerID: %w", err)
	}
	return oldValue.EmployerID, nil
}

// ResetEmployerID resets all changes to the "employer_id" field.
func (m *JobMutation) ResetEmployerID() {
	m.employer = nil
}

// SetContractorID sets the "contractor_id" field.
func (m *JobMutation) SetContractorID(u uuid.UUID) {
	m.contractor = &u
}

// ContractorID returns the value of the "contractor_id" field in the mutation.
func (m *JobMutation) ContractorID() (r uuid.UUID, exists bool) {
	v := m.contractor
	if v == nil {
		return
	}
	return *v, true
}

// OldContractorID returns the old "contractor_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldContractorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractorID: %w", err)
	}
	return oldValue.ContractorID, nil
}

// ClearContractorID clears the value of the "contractor_id" field.
func (m *JobMutation) ClearContractorID() {
	m.contractor = nil
	m.clearedFields[job.FieldContractorID] = struct{}{}
}

// ContractorIDCleared returns if the "contractor_id" field was cleared in this mutation.
func (m *JobMutation) ContractorIDCleared() bool {
	_, ok := m.clearedFields[job.FieldContractorID]
	return ok
}

// ResetContractorID resets all changes to the "contractor_id" field.
func (m *JobMutation) ResetContractorID() {
	m.contractor = nil
	delete(m.clearedFields, job.FieldContractorID)
}

// SetState sets the "state" field.
func (m *JobMutation) SetState(j job.State) {
	m.state = &j
}

// State returns the value of the "state" field in the mutation.
func (m *JobMutation) State() (r job.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldState(ctx context.Context) (v job.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *JobMutation) ResetState() {
	m.state = nil
}

// SetInvoiceInterval sets the "invoice_interval" field.
func (m *JobMutation) SetInvoiceInterval(i int) {
	m.invoice_interval = &i
	m.addinvoice_interval = nil
}

// InvoiceInterval returns the value of the "invoice_interval" field in the mutation.
func (m *JobMutation) InvoiceInterval() (r int, exists bool) {
	v := m.invoice_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceInterval returns the old "invoice_interval" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldInvoiceInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceInterval: %w", err)
	}
	return oldValue.InvoiceInterval, nil
}

// AddInvoiceInterval adds i to the "invoice_interval" field.
func (m *JobMutation) AddInvoiceInterval(i int) {
	if m.addinvoice_interval != nil {
		*m.addinvoice_interval += i
	} else {
		m.addinvoice_interval = &i
	}
}

// AddedInvoiceInterval returns the value that was added to the "invoice_interval" field in this mutation.
func (m *JobMutation) AddedInvoiceInterval() (r int, exists bool) {
	v := m.addinvoice_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceInterval resets all changes to the "invoice_interval" field.
func (m *JobMutation) ResetInvoiceInterval() {
	m.invoice_interval = nil
	m.addinvoice_interval = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearEmployer clears the "employer" edge to the User entity.
func (m *JobMutation) ClearEmployer() {
	m.clearedemployer = true
	m.clearedFields[job.FieldEmployerID] = struct{}{}
}

// EmployerCleared reports if the "employer" edge to the User entity was cleared.
func (m *JobMutation) EmployerCleared() bool {
	return m.clearedemployer
}

// EmployerIDs returns the "employer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) EmployerIDs() (ids []uuid.UUID) {
	if id := m.employer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployer resets all changes to the "employer" edge.
func (m *JobMutation) ResetEmployer() {
	m.employer = nil
	m.clearedemployer = false
}

// ClearContractor clears the "contractor" edge to the User entity.
func (m *JobMutation) ClearContractor() {
	m.clearedcontractor = true
	m.clearedFields[job.FieldContractorID] = struct{}{}
}

// ContractorCleared reports if the "contractor" edge to the User entity was cleared.
func (m *JobMutation) ContractorCleared() bool {
	return m.ContractorIDCleared() || m.clearedcontractor
}

// ContractorIDs returns the "contractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractorID instead. It exists only for internal usage by the builders.
func (m *JobMutation) ContractorIDs() (ids []uuid.UUID) {
	if id := m.contractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContractor resets all changes to the "contractor" edge.
func (m *JobMutation) ResetContractor() {
	m.contractor = nil
	m.clearedcontractor = false
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *JobMutation) AddInvoiceIDs(ids ...uuid.UUID) {
	if m.invoices == nil {
		m.invoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *JobMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *JobMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *JobMutation) RemoveInvoiceIDs(ids ...uuid.UUID) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *JobMutation) RemovedInvoicesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *JobMutation) InvoicesIDs() (ids []uuid.UUID) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *JobMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// AddApplicationIDs adds the "applications" edge to the JobApplication entity by ids.
func (m *JobMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the JobApplication entity.
func (m *JobMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the JobApplication entity was cleared.
func (m *JobMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the JobApplication entity by IDs.
func (m *JobMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the JobApplication entity.
func (m *JobMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *JobMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *JobMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.rate != nil {
		fields = append(fields, job.FieldRate)
	}
	if m.duration != nil {
		fields = append(fields, job.FieldDuration)
	}
	if m.employer != nil {
		fields = append(fields, job.FieldEmployerID)
	}
	if m.contractor != nil {
		fields = append(fields, job.FieldContractorID)
	}
	if m.state != nil {
		fields = append(fields, job.FieldState)
	}
	if m.invoice_interval != nil {
		fields = append(fields, job.FieldInvoiceInterval)
	}
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldRate:
		return m.Rate()
	case job.FieldDuration:
		return m.Duration()
	case job.FieldEmployerID:
		return m.EmployerID()
	case job.FieldContractorID:
		return m.ContractorID()
	case job.FieldState:
		return m.State()
	case job.FieldInvoiceInterval:
		return m.InvoiceInterval()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldRate:
		return m.OldRate(ctx)
	case job.FieldDuration:
		return m.OldDuration(ctx)
	case job.FieldEmployerID:
		return m.OldEmployerID(ctx)
	case job.FieldContractorID:
		return m.OldContractorID(ctx)
	case job.FieldState:
		return m.OldState(ctx)
	case job.FieldInvoiceInterval:
		return m.OldInvoiceInterval(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case job.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case job.FieldEmployerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployerID(v)
		return nil
	case job.FieldContractorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractorID(v)
		return nil
	case job.FieldState:
		v, ok := value.(job.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case job.FieldInvoiceInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceInterval(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addrate != nil {
		fields = append(fields, job.FieldRate)
	}
	if m.addduration != nil {
		fields = append(fields, job.FieldDuration)
	}
	if m.addinvoice_interval != nil {
		fields = append(fields, job.FieldInvoiceInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldRate:
		return m.AddedRate()
	case job.FieldDuration:
		return m.AddedDuration()
	case job.FieldInvoiceInterval:
		return m.AddedInvoiceInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case job.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case job.FieldInvoiceInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceInterval(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldContractorID) {
		fields = append(fields, job.FieldContractorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldContractorID:
		m.ClearContractorID()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldRate:
		m.ResetRate()
		return nil
	case job.FieldDuration:
		m.ResetDuration()
		return nil
	case job.FieldEmployerID:
		m.ResetEmployerID()
		return nil
	case job.FieldContractorID:
		m.ResetContractorID()
		return nil
	case job.FieldState:
		m.ResetState()
		return nil
	case job.FieldInvoiceInterval:
		m.ResetInvoiceInterval()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.employer != nil {
		edges = append(edges, job.EdgeEmployer)
	}
	if m.contractor != nil {
		edges = append(edges, job.EdgeContractor)
	}
	if m.invoices != nil {
		edges = append(edges, job.EdgeInvoices)
	}
	if m.applications != nil {
		edges = append(edges, job.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeEmployer:
		if id := m.employer; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeContractor:
		if id := m.contractor; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinvoices != nil {
		edges = append(edges, job.EdgeInvoices)
	}
	if m.removedapplications != nil {
		edges = append(edges, job.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedemployer {
		edges = append(edges, job.EdgeEmployer)
	}
	if m.clearedcontractor {
		edges = append(edges, job.EdgeContractor)
	}
	if m.clearedinvoices {
		edges = append(edges, job.EdgeInvoices)
	}
	if m.clearedapplications {
		edges = append(edges, job.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeEmployer:
		return m.clearedemployer
	case job.EdgeContractor:
		return m.clearedcontractor
	case job.EdgeInvoices:
		return m.clearedinvoices
	case job.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeEmployer:
		m.ClearEmployer()
		return nil
	case job.EdgeContractor:
		m.ClearContractor()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeEmployer:
		m.ResetEmployer()
		return nil
	case job.EdgeContractor:
		m.ResetContractor()
		return nil
	case job.EdgeInvoices:
		m.ResetInvoices()
		return nil
	case job.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobApplicationMutation represents an operation that mutates the JobApplication nodes in the graph.
type JobApplicationMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	state             *jobapplication.State
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	contractor        *uuid.UUID
	clearedcontractor bool
	job               *uuid.UUID
	clearedjob        bool
	done              bool
	oldValue          func(context.Context) (*JobApplication, error)
	predicates        []predicate.JobApplication
}

var _ ent.Mutation = (*JobApplicationMutation)(nil)

// jobapplicationOption allows management of the mutation configuration using functional options.
type jobapplicationOption func(*JobApplicationMutation)

// newJobApplicationMutation creates new mutation for the JobApplication entity.
func newJobApplicationMutation(c config, op Op, opts ...jobapplicationOption) *JobApplicationMutation {
	m := &JobApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeJobApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobApplicationID sets the ID field of the mutation.
func withJobApplicationID(id uuid.UUID) jobapplicationOption {
	return func(m *JobApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *JobApplication
		)
		m.oldValue = func(ctx context.Context) (*JobApplication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobApplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobApplication sets the old JobApplication of the mutation.
func withJobApplication(node *JobApplication) jobapplicationOption {
	return func(m *JobApplicationMutation) {
		m.oldValue = func(context.Context) (*JobApplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobApplication entities.
func (m *JobApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobApplication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *JobApplicationMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobApplicationMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobApplication entity.
// If the JobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobApplicationMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobApplicationMutation) ResetJobID() {
	m.job = nil
}

// SetContractorID sets the "contractor_id" field.
func (m *JobApplicationMutation) SetContractorID(u uuid.UUID) {
	m.contractor = &u
}

// ContractorID returns the value of the "contractor_id" field in the mutation.
func (m *JobApplicationMutation) ContractorID() (r uuid.UUID, exists bool) {
	v := m.contractor
	if v == nil {
		return
	}
	return *v, true
}

// OldContractorID returns the old "contractor_id" field's value of the JobApplication entity.
// If the JobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobApplicationMutation) OldContractorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractorID: %w", err)
	}
	return oldValue.ContractorID, nil
}

// ResetContractorID resets all changes to the "contractor_id" field.
func (m *JobApplicationMutation) ResetContractorID() {
	m.contractor = nil
}

// SetState sets the "state" field.
func (m *JobApplicationMutation) SetState(j jobapplication.State) {
	m.state = &j
}

// State returns the value of the "state" field in the mutation.
func (m *JobApplicationMutation) State() (r jobapplication.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the JobApplication entity.
// If the JobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobApplicationMutation) OldState(ctx context.Context) (v jobapplication.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *JobApplicationMutation) ResetState() {
	m.state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobApplication entity.
// If the JobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobApplication entity.
// If the JobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearContractor clears the "contractor" edge to the User entity.
func (m *JobApplicationMutation) ClearContractor() {
	m.clearedcontractor = true
	m.clearedFields[jobapplication.FieldContractorID] = struct{}{}
}

// ContractorCleared reports if the "contractor" edge to the User entity was cleared.
func (m *JobApplicationMutation) ContractorCleared() bool {
	return m.clearedcontractor
}

// ContractorIDs returns the "contractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractorID instead. It exists only for internal usage by the builders.
func (m *JobApplicationMutation) ContractorIDs() (ids []uuid.UUID) {
	if id := m.contractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContractor resets all changes to the "contractor" edge.
func (m *JobApplicationMutation) ResetContractor() {
	m.contractor = nil
	m.clearedcontractor = false
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobApplicationMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobapplication.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobApplicationMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobApplicationMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobApplicationMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobApplicationMutation builder.
func (m *JobApplicationMutation) Where(ps ...predicate.JobApplication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobApplication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobApplication).
func (m *JobApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobApplicationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.job != nil {
		fields = append(fields, jobapplication.FieldJobID)
	}
	if m.contractor != nil {
		fields = append(fields, jobapplication.FieldContractorID)
	}
	if m.state != nil {
		fields = append(fields, jobapplication.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, jobapplication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobapplication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobapplication.FieldJobID:
		return m.JobID()
	case jobapplication.FieldContractorID:
		return m.ContractorID()
	case jobapplication.FieldState:
		return m.State()
	case jobapplication.FieldCreatedAt:
		return m.CreatedAt()
	case jobapplication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobapplication.FieldJobID:
		return m.OldJobID(ctx)
	case jobapplication.FieldContractorID:
		return m.OldContractorID(ctx)
	case jobapplication.FieldState:
		return m.OldState(ctx)
	case jobapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobapplication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobApplication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobapplication.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobapplication.FieldContractorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractorID(v)
		return nil
	case jobapplication.FieldState:
		v, ok := value.(jobapplication.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case jobapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobapplication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobApplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobApplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobApplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobApplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobApplication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobApplicationMutation) ResetField(name string) error {
	switch name {
	case jobapplication.FieldJobID:
		m.ResetJobID()
		return nil
	case jobapplication.FieldContractorID:
		m.ResetContractorID()
		return nil
	case jobapplication.FieldState:
		m.ResetState()
		return nil
	case jobapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobapplication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobApplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.contractor != nil {
		edges = append(edges, jobapplication.EdgeContractor)
	}
	if m.job != nil {
		edges = append(edges, jobapplication.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobapplication.EdgeContractor:
		if id := m.contractor; id != nil {
			return []ent.Value{*id}
		}
	case jobapplication.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontractor {
		edges = append(edges, jobapplication.EdgeContractor)
	}
	if m.clearedjob {
		edges = append(edges, jobapplication.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case jobapplication.EdgeContractor:
		return m.clearedcontractor
	case jobapplication.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobApplicationMutation) ClearEdge(name string) error {
	switch name {
	case jobapplication.EdgeContractor:
		m.ClearContractor()
		return nil
	case jobapplication.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobApplication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobApplicationMutation) ResetEdge(name string) error {
	switch name {
	case jobapplication.EdgeContractor:
		m.ResetContractor()
		return nil
	case jobapplication.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobApplication edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	name                            *string
	email                           *string
	password_hash                   *string
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	jobsAsEmployer                  map[uuid.UUID]struct{}
	removedjobsAsEmployer           map[uuid.UUID]struct{}
	clearedjobsAsEmployer           bool
	jobsAsContractor                map[uuid.UUID]struct{}
	removedjobsAsContractor         map[uuid.UUID]struct{}
	clearedjobsAsContractor         bool
	applicationsAsContractor        map[uuid.UUID]struct{}
	removedapplicationsAsContractor map[uuid.UUID]struct{}
	clearedapplicationsAsContractor bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddJobsAsEmployerIDs adds the "jobsAsEmployer" edge to the Job entity by ids.
func (m *UserMutation) AddJobsAsEmployerIDs(ids ...uuid.UUID) {
	if m.jobsAsEmployer == nil {
		m.jobsAsEmployer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.jobsAsEmployer[ids[i]] = struct{}{}
	}
}

// ClearJobsAsEmployer clears the "jobsAsEmployer" edge to the Job entity.
func (m *UserMutation) ClearJobsAsEmployer() {
	m.clearedjobsAsEmployer = true
}

// JobsAsEmployerCleared reports if the "jobsAsEmployer" edge to the Job entity was cleared.
func (m *UserMutation) JobsAsEmployerCleared() bool {
	return m.clearedjobsAsEmployer
}

// RemoveJobsAsEmployerIDs removes the "jobsAsEmployer" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobsAsEmployerIDs(ids ...uuid.UUID) {
	if m.removedjobsAsEmployer == nil {
		m.removedjobsAsEmployer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.jobsAsEmployer, ids[i])
		m.removedjobsAsEmployer[ids[i]] = struct{}{}
	}
}

// RemovedJobsAsEmployer returns the removed IDs of the "jobsAsEmployer" edge to the Job entity.
func (m *UserMutation) RemovedJobsAsEmployerIDs() (ids []uuid.UUID) {
	for id := range m.removedjobsAsEmployer {
		ids = append(ids, id)
	}
	return
}

// JobsAsEmployerIDs returns the "jobsAsEmployer" edge IDs in the mutation.
func (m *UserMutation) JobsAsEmployerIDs() (ids []uuid.UUID) {
	for id := range m.jobsAsEmployer {
		ids = append(ids, id)
	}
	return
}

// ResetJobsAsEmployer resets all changes to the "jobsAsEmployer" edge.
func (m *UserMutation) ResetJobsAsEmployer() {
	m.jobsAsEmployer = nil
	m.clearedjobsAsEmployer = false
	m.removedjobsAsEmployer = nil
}

// AddJobsAsContractorIDs adds the "jobsAsContractor" edge to the Job entity by ids.
func (m *UserMutation) AddJobsAsContractorIDs(ids ...uuid.UUID) {
	if m.jobsAsContractor == nil {
		m.jobsAsContractor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.jobsAsContractor[ids[i]] = struct{}{}
	}
}

// ClearJobsAsContractor clears the "jobsAsContractor" edge to the Job entity.
func (m *UserMutation) ClearJobsAsContractor() {
	m.clearedjobsAsContractor = true
}

// JobsAsContractorCleared reports if the "jobsAsContractor" edge to the Job entity was cleared.
func (m *UserMutation) JobsAsContractorCleared() bool {
	return m.clearedjobsAsContractor
}

// RemoveJobsAsContractorIDs removes the "jobsAsContractor" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobsAsContractorIDs(ids ...uuid.UUID) {
	if m.removedjobsAsContractor == nil {
		m.removedjobsAsContractor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.jobsAsContractor, ids[i])
		m.removedjobsAsContractor[ids[i]] = struct{}{}
	}
}

// RemovedJobsAsContractor returns the removed IDs of the "jobsAsContractor" edge to the Job entity.
func (m *UserMutation) RemovedJobsAsContractorIDs() (ids []uuid.UUID) {
	for id := range m.removedjobsAsContractor {
		ids = append(ids, id)
	}
	return
}

// JobsAsContractorIDs returns the "jobsAsContractor" edge IDs in the mutation.
func (m *UserMutation) JobsAsContractorIDs() (ids []uuid.UUID) {
	for id := range m.jobsAsContractor {
		ids = append(ids, id)
	}
	return
}

// ResetJobsAsContractor resets all changes to the "jobsAsContractor" edge.
func (m *UserMutation) ResetJobsAsContractor() {
	m.jobsAsContractor = nil
	m.clearedjobsAsContractor = false
	m.removedjobsAsContractor = nil
}

// AddApplicationsAsContractorIDs adds the "applicationsAsContractor" edge to the JobApplication entity by ids.
func (m *UserMutation) AddApplicationsAsContractorIDs(ids ...uuid.UUID) {
	if m.applicationsAsContractor == nil {
		m.applicationsAsContractor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicationsAsContractor[ids[i]] = struct{}{}
	}
}

// ClearApplicationsAsContractor clears the "applicationsAsContractor" edge to the JobApplication entity.
func (m *UserMutation) ClearApplicationsAsContractor() {
	m.clearedapplicationsAsContractor = true
}

// ApplicationsAsContractorCleared reports if the "applicationsAsContractor" edge to the JobApplication entity was cleared.
func (m *UserMutation) ApplicationsAsContractorCleared() bool {
	return m.clearedapplicationsAsContractor
}

// RemoveApplicationsAsContractorIDs removes the "applicationsAsContractor" edge to the JobApplication entity by IDs.
func (m *UserMutation) RemoveApplicationsAsContractorIDs(ids ...uuid.UUID) {
	if m.removedapplicationsAsContractor == nil {
		m.removedapplicationsAsContractor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicationsAsContractor, ids[i])
		m.removedapplicationsAsContractor[ids[i]] = struct{}{}
	}
}

// RemovedApplicationsAsContractor returns the removed IDs of the "applicationsAsContractor" edge to the JobApplication entity.
func (m *UserMutation) RemovedApplicationsAsContractorIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicationsAsContractor {
		ids = append(ids, id)
	}
	return
}

// ApplicationsAsContractorIDs returns the "applicationsAsContractor" edge IDs in the mutation.
func (m *UserMutation) ApplicationsAsContractorIDs() (ids []uuid.UUID) {
	for id := range m.applicationsAsContractor {
		ids = append(ids, id)
	}
	return
}

// ResetApplicationsAsContractor resets all changes to the "applicationsAsContractor" edge.
func (m *UserMutation) ResetApplicationsAsContractor() {
	m.applicationsAsContractor = nil
	m.clearedapplicationsAsContractor = false
	m.removedapplicationsAsContractor = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.jobsAsEmployer != nil {
		edges = append(edges, user.EdgeJobsAsEmployer)
	}
	if m.jobsAsContractor != nil {
		edges = append(edges, user.EdgeJobsAsContractor)
	}
	if m.applicationsAsContractor != nil {
		edges = append(edges, user.EdgeApplicationsAsContractor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobsAsEmployer:
		ids := make([]ent.Value, 0, len(m.jobsAsEmployer))
		for id := range m.jobsAsEmployer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobsAsContractor:
		ids := make([]ent.Value, 0, len(m.jobsAsContractor))
		for id := range m.jobsAsContractor {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApplicationsAsContractor:
		ids := make([]ent.Value, 0, len(m.applicationsAsContractor))
		for id := range m.applicationsAsContractor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedjobsAsEmployer != nil {
		edges = append(edges, user.EdgeJobsAsEmployer)
	}
	if m.removedjobsAsContractor != nil {
		edges = append(edges, user.EdgeJobsAsContractor)
	}
	if m.removedapplicationsAsContractor != nil {
		edges = append(edges, user.EdgeApplicationsAsContractor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobsAsEmployer:
		ids := make([]ent.Value, 0, len(m.removedjobsAsEmployer))
		for id := range m.removedjobsAsEmployer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobsAsContractor:
		ids := make([]ent.Value, 0, len(m.removedjobsAsContractor))
		for id := range m.removedjobsAsContractor {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApplicationsAsContractor:
		ids := make([]ent.Value, 0, len(m.removedapplicationsAsContractor))
		for id := range m.removedapplicationsAsContractor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjobsAsEmployer {
		edges = append(edges, user.EdgeJobsAsEmployer)
	}
	if m.clearedjobsAsContractor {
		edges = append(edges, user.EdgeJobsAsContractor)
	}
	if m.clearedapplicationsAsContractor {
		edges = append(edges, user.EdgeApplicationsAsContractor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeJobsAsEmployer:
		return m.clearedjobsAsEmployer
	case user.EdgeJobsAsContractor:
		return m.clearedjobsAsContractor
	case user.EdgeApplicationsAsContractor:
		return m.clearedapplicationsAsContractor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeJobsAsEmployer:
		m.ResetJobsAsEmployer()
		return nil
	case user.EdgeJobsAsContractor:
		m.ResetJobsAsContractor()
		return nil
	case user.EdgeApplicationsAsContractor:
		m.ResetApplicationsAsContractor()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
