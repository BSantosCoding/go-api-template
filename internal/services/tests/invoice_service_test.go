package services_test

import (
	"context"
	"errors"
	"testing"
	"time"

	mock_storage "go-api-template/internal/mocks" // Assuming mocks are generated here
	"go-api-template/internal/models"
	"go-api-template/internal/services"
	"go-api-template/internal/storage"
	"go-api-template/internal/transport/dto"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Helper to create a pointer to a InvoiceState
func ptrInvoiceState(s models.InvoiceState) *models.InvoiceState { return &s }

func setupInvoiceServiceTest(t *testing.T) (context.Context, services.InvoiceService, *mock_storage.MockInvoiceRepository, *mock_storage.MockJobRepository, *gomock.Controller) {
	ctrl := gomock.NewController(t)
	mockInvoiceRepo := mock_storage.NewMockInvoiceRepository(ctrl)
	mockJobRepo := mock_storage.NewMockJobRepository(ctrl)
	invoiceService := services.NewInvoiceService(mockInvoiceRepo, mockJobRepo)
	ctx := context.Background()
	return ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl
}

func TestInvoiceService_CreateInvoice_Success_FullInterval(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{
		JobID:  jobID,
		UserId: contractorID,
	}

	mockJob := &models.Job{
		ID:              jobID,
		EmployerID:      uuid.New(),
		ContractorID:    &contractorID,
		State:           models.JobStateOngoing, // Correct state
		Rate:            100.0,
		Duration:        40,
		InvoiceInterval: 10, // 4 intervals
	}

	maxIntervalNum := 1 // Previous interval was 1
	nextIntervalNumber := maxIntervalNum + 1
	hoursForThisInterval := mockJob.InvoiceInterval
	expectedValue := mockJob.Rate * float64(hoursForThisInterval)

	expectedInvoice := &models.Invoice{
		// ID will be generated by repo, but we need to match the input to Create
		JobID:          jobID,
		IntervalNumber: nextIntervalNumber,
		Value:          expectedValue,
		State:          models.InvoiceStateWaiting,
	}

	// Mock GetJobByID
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)
	// Mock GetMaxIntervalForJob
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(maxIntervalNum, nil).Times(1)
	// Mock Create
	mockInvoiceRepo.EXPECT().Create(ctx, gomock.Any()).DoAndReturn(
		func(ctx context.Context, inv *models.Invoice) (*models.Invoice, error) {
			// Assert the input to Create matches expectations (except ID)
			assert.Equal(t, expectedInvoice.JobID, inv.JobID)
			assert.Equal(t, expectedInvoice.IntervalNumber, inv.IntervalNumber)
			assert.Equal(t, expectedInvoice.Value, inv.Value)
			assert.Equal(t, expectedInvoice.State, inv.State)
			assert.NotEqual(t, uuid.Nil, inv.ID) // Ensure ID was generated
			// Return the input invoice with a generated ID for the service result
			inv.ID = uuid.New()
			inv.CreatedAt = time.Now()
			inv.UpdatedAt = time.Now()
			return inv, nil
		}).Times(1)

	invoice, err := invoiceService.CreateInvoice(ctx, req)

	require.NoError(t, err)
	assert.NotNil(t, invoice)
	assert.Equal(t, jobID, invoice.JobID)
	assert.Equal(t, nextIntervalNumber, invoice.IntervalNumber)
	assert.Equal(t, expectedValue, invoice.Value)
	assert.Equal(t, models.InvoiceStateWaiting, invoice.State)
}

func TestInvoiceService_CreateInvoice_Success_PartialLastInterval(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{
		JobID:  jobID,
		UserId: contractorID,
	}

	mockJob := &models.Job{
		ID:              jobID,
		ContractorID:    &contractorID,
		State:           models.JobStateOngoing,
		Rate:            50.0,
		Duration:        35, // 3 full intervals (10) + 1 partial (5) = 4 intervals total
		InvoiceInterval: 10,
	}

	maxIntervalNum := 3 // Previous interval was 3, this is the 4th (last)
	nextIntervalNumber := maxIntervalNum + 1
	remainderHours := mockJob.Duration % mockJob.InvoiceInterval // 5
	expectedValue := mockJob.Rate * float64(remainderHours)

	expectedInvoiceInput := &models.Invoice{
		JobID:          jobID,
		IntervalNumber: nextIntervalNumber,
		Value:          expectedValue,
		State:          models.InvoiceStateWaiting,
	}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(maxIntervalNum, nil)
	mockInvoiceRepo.EXPECT().Create(ctx, gomock.Any()).DoAndReturn(
		func(ctx context.Context, inv *models.Invoice) (*models.Invoice, error) {
			assert.Equal(t, expectedInvoiceInput.JobID, inv.JobID)
			assert.Equal(t, expectedInvoiceInput.IntervalNumber, inv.IntervalNumber)
			assert.Equal(t, expectedInvoiceInput.Value, inv.Value)
			assert.Equal(t, expectedInvoiceInput.State, inv.State)
			inv.ID = uuid.New()
			return inv, nil
		})

	invoice, err := invoiceService.CreateInvoice(ctx, req)

	require.NoError(t, err)
	assert.NotNil(t, invoice)
	assert.Equal(t, nextIntervalNumber, invoice.IntervalNumber)
	assert.Equal(t, expectedValue, invoice.Value)
}

func TestInvoiceService_CreateInvoice_Success_WithAdjustment(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	adjustment := -25.50
	req := &dto.CreateInvoiceRequest{
		JobID:      jobID,
		UserId:     contractorID,
		Adjustment: &adjustment,
	}

	mockJob := &models.Job{
		ID:              jobID,
		ContractorID:    &contractorID,
		State:           models.JobStateOngoing,
		Rate:            100.0,
		Duration:        40,
		InvoiceInterval: 10,
	}

	maxIntervalNum := 0
	nextIntervalNumber := 1
	hoursForThisInterval := mockJob.InvoiceInterval
	expectedBaseValue := mockJob.Rate * float64(hoursForThisInterval)
	expectedFinalValue := expectedBaseValue + adjustment

	expectedInvoiceInput := &models.Invoice{
		JobID:          jobID,
		IntervalNumber: nextIntervalNumber,
		Value:          expectedFinalValue,
		State:          models.InvoiceStateWaiting,
	}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(maxIntervalNum, nil)
	mockInvoiceRepo.EXPECT().Create(ctx, gomock.Any()).DoAndReturn(
		func(ctx context.Context, inv *models.Invoice) (*models.Invoice, error) {
			assert.Equal(t, expectedInvoiceInput.Value, inv.Value) // Check adjusted value
			inv.ID = uuid.New()
			return inv, nil
		})

	invoice, err := invoiceService.CreateInvoice(ctx, req)

	require.NoError(t, err)
	assert.NotNil(t, invoice)
	assert.Equal(t, expectedFinalValue, invoice.Value)
}

func TestInvoiceService_CreateInvoice_Error_JobNotFound(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.CreateInvoiceRequest{JobID: uuid.New(), UserId: uuid.New()}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: req.JobID}).Return(nil, storage.ErrNotFound).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound))
}

func TestInvoiceService_CreateInvoice_Error_JobRepoError(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.CreateInvoiceRequest{JobID: uuid.New(), UserId: uuid.New()}
	repoErr := errors.New("db error")

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: req.JobID}).Return(nil, repoErr).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error creating job") // Error message from service
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_CreateInvoice_Error_Forbidden_NotContractor(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	actualContractorID := uuid.New()
	requestingUserID := uuid.New() // Different user
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: requestingUserID}

	mockJob := &models.Job{ID: jobID, ContractorID: &actualContractorID, State: models.JobStateOngoing}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_CreateInvoice_Error_Forbidden_NoContractor(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	requestingUserID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: requestingUserID}

	mockJob := &models.Job{ID: jobID, ContractorID: nil, State: models.JobStateOngoing} // No contractor

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_CreateInvoice_Error_InvalidState_JobNotOngoing(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}

	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateWaiting} // Wrong state

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrInvalidState))
}

func TestInvoiceService_CreateInvoice_Error_GetMaxIntervalRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateOngoing}
	repoErr := errors.New("db error")

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(0, repoErr).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error creating job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_CreateInvoice_Error_InvalidInvoiceInterval_ZeroJobInterval(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateOngoing, InvoiceInterval: 0} // Invalid interval

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(0, nil) // Assume this succeeds

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrInvalidInvoiceInterval))
}

func TestInvoiceService_CreateInvoice_Error_InvalidInvoiceInterval_ExceedsMax(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateOngoing, Duration: 20, InvoiceInterval: 10} // Max 2 intervals

	maxIntervalNum := 2 // Already created 2 intervals

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(maxIntervalNum, nil)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrInvalidInvoiceInterval))
}

func TestInvoiceService_CreateInvoice_Error_CreateRepoConflict(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateOngoing, Duration: 40, InvoiceInterval: 10}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(0, nil)
	mockInvoiceRepo.EXPECT().Create(ctx, gomock.Any()).Return(nil, storage.ErrConflict).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrConflict))
}

func TestInvoiceService_CreateInvoice_Error_CreateRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.CreateInvoiceRequest{JobID: jobID, UserId: contractorID}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID, State: models.JobStateOngoing, Duration: 40, InvoiceInterval: 10}
	repoErr := errors.New("db write error")

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().GetMaxIntervalForJob(ctx, &dto.GetMaxIntervalForJobRequest{JobID: jobID}).Return(0, nil)
	mockInvoiceRepo.EXPECT().Create(ctx, gomock.Any()).Return(nil, repoErr).Times(1)

	_, err := invoiceService.CreateInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error creating job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_GetInvoiceByID_Success_AsEmployer(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	req := &dto.GetInvoiceByIDRequest{ID: invoiceID, UserId: employerID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(mockInvoice, nil).Times(1)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	invoice, err := invoiceService.GetInvoiceByID(ctx, req)

	require.NoError(t, err)
	assert.Equal(t, mockInvoice, invoice)
}

func TestInvoiceService_GetInvoiceByID_Success_AsContractor(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	req := &dto.GetInvoiceByIDRequest{ID: invoiceID, UserId: contractorID} // Requesting user is contractor

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(mockInvoice, nil).Times(1)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	invoice, err := invoiceService.GetInvoiceByID(ctx, req)

	require.NoError(t, err)
	assert.Equal(t, mockInvoice, invoice)
}

func TestInvoiceService_GetInvoiceByID_Error_InvoiceNotFound(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.GetInvoiceByIDRequest{ID: uuid.New(), UserId: uuid.New()}

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(nil, storage.ErrNotFound).Times(1)

	_, err := invoiceService.GetInvoiceByID(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound))
}

func TestInvoiceService_GetInvoiceByID_Error_InvoiceRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.GetInvoiceByIDRequest{ID: uuid.New(), UserId: uuid.New()}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(nil, repoErr).Times(1)

	_, err := invoiceService.GetInvoiceByID(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting invoice")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_GetInvoiceByID_Error_JobRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	req := &dto.GetInvoiceByIDRequest{ID: invoiceID, UserId: uuid.New()}
	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(nil, repoErr).Times(1)

	_, err := invoiceService.GetInvoiceByID(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_GetInvoiceByID_Error_Forbidden(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	otherUserID := uuid.New() // User not associated with the job
	req := &dto.GetInvoiceByIDRequest{ID: invoiceID, UserId: otherUserID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID}
	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, req).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)

	_, err := invoiceService.GetInvoiceByID(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_UpdateInvoiceState_Success(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	newState := models.InvoiceStateComplete
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: newState, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting} // Correct initial state
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}
	updatedInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: newState, UpdatedAt: time.Now()}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil).Times(1)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)
	mockInvoiceRepo.EXPECT().UpdateState(ctx, req).Return(updatedInvoice, nil).Times(1)

	invoice, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.NoError(t, err)
	assert.Equal(t, updatedInvoice, invoice)
}

func TestInvoiceService_UpdateInvoiceState_Error_InvoiceNotFound(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.UpdateInvoiceStateRequest{ID: uuid.New(), NewState: models.InvoiceStateComplete, UserId: uuid.New()}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: req.ID}).Return(nil, storage.ErrNotFound).Times(1)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound))
}

func TestInvoiceService_UpdateInvoiceState_Error_InvoiceRepoError_Get(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.UpdateInvoiceStateRequest{ID: uuid.New(), NewState: models.InvoiceStateComplete, UserId: uuid.New()}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: req.ID}).Return(nil, repoErr).Times(1)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting invoice")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_UpdateInvoiceState_Error_JobRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: models.InvoiceStateComplete, UserId: uuid.New()}
	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(nil, repoErr).Times(1)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_UpdateInvoiceState_Error_Forbidden_NotContractor(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	actualContractorID := uuid.New()
	requestingUserID := uuid.New() // Different user
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: models.InvoiceStateComplete, UserId: requestingUserID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &actualContractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_UpdateInvoiceState_Error_InvalidTransition(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	newState := models.InvoiceStateWaiting // Invalid transition: Complete -> Waiting
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: newState, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateComplete} // Current state is Complete
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrInvalidTransition))
}

func TestInvoiceService_UpdateInvoiceState_Error_UpdateRepoNotFound(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	newState := models.InvoiceStateComplete
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: newState, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().UpdateState(ctx, req).Return(nil, storage.ErrNotFound).Times(1) // Repo returns NotFound on Update

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound)) // Service maps this
}

func TestInvoiceService_UpdateInvoiceState_Error_UpdateRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	newState := models.InvoiceStateComplete
	req := &dto.UpdateInvoiceStateRequest{ID: invoiceID, NewState: newState, UserId: contractorID}
	repoErr := errors.New("db write error")

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().UpdateState(ctx, req).Return(nil, repoErr).Times(1)

	_, err := invoiceService.UpdateInvoiceState(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error updating invoice")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_DeleteInvoice_Success(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting} // Correct state
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil).Times(1)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)
	mockInvoiceRepo.EXPECT().Delete(ctx, req).Return(nil).Times(1)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.NoError(t, err)
}

func TestInvoiceService_DeleteInvoice_Error_InvoiceNotFound(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.DeleteInvoiceRequest{ID: uuid.New(), UserId: uuid.New()}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: req.ID}).Return(nil, storage.ErrNotFound).Times(1)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound))
}

func TestInvoiceService_DeleteInvoice_Error_InvoiceRepoError_Get(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, _, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.DeleteInvoiceRequest{ID: uuid.New(), UserId: uuid.New()}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: req.ID}).Return(nil, repoErr).Times(1)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting invoice")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_DeleteInvoice_Error_JobRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: uuid.New()}
	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	repoErr := errors.New("db error")

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(nil, repoErr).Times(1)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_DeleteInvoice_Error_Forbidden_NotContractor(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	actualContractorID := uuid.New()
	requestingUserID := uuid.New() // Different user
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: requestingUserID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &actualContractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_DeleteInvoice_Error_InvalidState_NotWaiting(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateComplete} // Wrong state
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrInvalidState))
}

func TestInvoiceService_DeleteInvoice_Error_DeleteRepoNotFound(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: contractorID}

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().Delete(ctx, req).Return(storage.ErrNotFound).Times(1) // Repo returns NotFound on Delete

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound)) // Service maps this
}

func TestInvoiceService_DeleteInvoice_Error_DeleteRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	invoiceID := uuid.New()
	jobID := uuid.New()
	contractorID := uuid.New()
	req := &dto.DeleteInvoiceRequest{ID: invoiceID, UserId: contractorID}
	repoErr := errors.New("db delete error")

	mockInvoice := &models.Invoice{ID: invoiceID, JobID: jobID, State: models.InvoiceStateWaiting}
	mockJob := &models.Job{ID: jobID, ContractorID: &contractorID}

	mockInvoiceRepo.EXPECT().GetByID(ctx, &dto.GetInvoiceByIDRequest{ID: invoiceID}).Return(mockInvoice, nil)
	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().Delete(ctx, req).Return(repoErr).Times(1)

	err := invoiceService.DeleteInvoice(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error deleting invoice")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_ListInvoicesByJob_Success_AsEmployer(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	req := &dto.ListInvoicesByJobRequest{JobID: jobID, UserId: employerID, Limit: 5, Offset: 0}

	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}
	expectedInvoices := []models.Invoice{
		{ID: uuid.New(), JobID: jobID, State: models.InvoiceStateWaiting},
		{ID: uuid.New(), JobID: jobID, State: models.InvoiceStateComplete},
	}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)
	mockInvoiceRepo.EXPECT().ListByJob(ctx, req).Return(expectedInvoices, nil).Times(1)

	invoices, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.NoError(t, err)
	assert.Equal(t, expectedInvoices, invoices)
}

func TestInvoiceService_ListInvoicesByJob_Success_AsContractor(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	req := &dto.ListInvoicesByJobRequest{JobID: jobID, UserId: contractorID, Limit: 5, Offset: 0} // User is contractor

	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}
	expectedInvoices := []models.Invoice{
		{ID: uuid.New(), JobID: jobID, State: models.InvoiceStateWaiting},
	}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)
	mockInvoiceRepo.EXPECT().ListByJob(ctx, req).Return(expectedInvoices, nil).Times(1)

	invoices, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.NoError(t, err)
	assert.Equal(t, expectedInvoices, invoices)
}

func TestInvoiceService_ListInvoicesByJob_Error_JobNotFound(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.ListInvoicesByJobRequest{JobID: uuid.New(), UserId: uuid.New()}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: req.JobID}).Return(nil, storage.ErrNotFound).Times(1)

	_, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrNotFound))
}

func TestInvoiceService_ListInvoicesByJob_Error_JobRepoError(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	req := &dto.ListInvoicesByJobRequest{JobID: uuid.New(), UserId: uuid.New()}
	repoErr := errors.New("db error")

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: req.JobID}).Return(nil, repoErr).Times(1)

	_, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error getting job")
	assert.True(t, errors.Is(err, repoErr))
}

func TestInvoiceService_ListInvoicesByJob_Error_Forbidden(t *testing.T) {
	ctx, invoiceService, _, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	employerID := uuid.New()
	contractorID := uuid.New()
	otherUserID := uuid.New() // User not associated
	req := &dto.ListInvoicesByJobRequest{JobID: jobID, UserId: otherUserID}

	mockJob := &models.Job{ID: jobID, EmployerID: employerID, ContractorID: &contractorID}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil).Times(1)

	_, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.Error(t, err)
	assert.True(t, errors.Is(err, services.ErrForbidden))
}

func TestInvoiceService_ListInvoicesByJob_Error_ListRepoError(t *testing.T) {
	ctx, invoiceService, mockInvoiceRepo, mockJobRepo, ctrl := setupInvoiceServiceTest(t)
	defer ctrl.Finish()

	jobID := uuid.New()
	employerID := uuid.New()
	req := &dto.ListInvoicesByJobRequest{JobID: jobID, UserId: employerID}
	repoErr := errors.New("db list error")

	mockJob := &models.Job{ID: jobID, EmployerID: employerID}

	mockJobRepo.EXPECT().GetByID(ctx, &dto.GetJobByIDRequest{ID: jobID}).Return(mockJob, nil)
	mockInvoiceRepo.EXPECT().ListByJob(ctx, req).Return(nil, repoErr).Times(1)

	_, err := invoiceService.ListInvoicesByJob(ctx, req)

	require.Error(t, err)
	assert.Contains(t, err.Error(), "internal error listing invoices")
	assert.True(t, errors.Is(err, repoErr))
}