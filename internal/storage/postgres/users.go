package postgres

import (
	"context"
	"errors" // Import errors package
	"log"    // For logging errors

	"go-api-template/internal/models"
	"go-api-template/internal/storage" // Import the interface package
	"go-api-template/internal/transport/dto"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn" // For checking specific errors
	"github.com/jackc/pgx/v5/pgxpool"
)

// UserRepo implements the storage.UserRepository interface using PostgreSQL.
type UserRepo struct {
	db *pgxpool.Pool
}

// NewUserRepo creates a new UserRepo.
func NewUserRepo(db *pgxpool.Pool) *UserRepo {
	return &UserRepo{db: db}
}

// Compile-time check to ensure UserRepo implements UserRepository
var _ storage.UserRepository = (*UserRepo)(nil)

func (r *UserRepo) GetAll(ctx context.Context) ([]models.User, error) {
	query := `SELECT id, name, email FROM users ORDER BY name ASC;` // Adjust table/column names if needed
	rows, err := r.db.Query(ctx, query)
	if err != nil {
		log.Printf("Error querying all users: %v\n", err)
		return nil, err
	}
	defer rows.Close()

	users, err := pgx.CollectRows(rows, pgx.RowToStructByName[models.User])
	if err != nil {
		log.Printf("Error scanning users: %v\n", err)
		return nil, err
	}

	// Return empty slice instead of nil if no users found
	if users == nil {
		users = []models.User{}
	}

	return users, nil
}

func (r *UserRepo) GetByID(ctx context.Context, id *dto.GetUserByIdRequest) (*models.User, error) {
	query := `SELECT id, name, email FROM users WHERE id = $1;` // Adjust table/column names
	row := r.db.QueryRow(ctx, query, id.ID)

	var user models.User
	err := row.Scan(&user.ID, &user.Name, &user.Email)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, storage.ErrNotFound // Use a custom error type later if needed
		}
		log.Printf("Error scanning user by ID %s: %v\n", id, err)
		return nil, err
	}
	return &user, nil
}

func (r *UserRepo) Create(ctx context.Context, user *dto.CreateUserRequest) (*models.User, error) {
	sql := `INSERT INTO users (id, name, email)
             VALUES ($1, $2, $3)
             RETURNING id, name, email, created_at, updated_at`

	createdUser := &models.User{}

	err := r.db.QueryRow(ctx, sql, user.ID, user.Name, user.Email).Scan(
        &createdUser.ID,
        &createdUser.Name,
        &createdUser.Email,
        &createdUser.CreatedAt,
        &createdUser.UpdatedAt,
    )
	if err != nil {
		// Check for unique constraint violation (example)
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" { // 23505 is unique_violation
			log.Printf("Attempted to create user with duplicate ID or email: %v\n", err)
			return nil, storage.ErrConflict // Use a custom error type later
		}
		log.Printf("Error creating user: %v\n", err)
		return nil, err
	}
	// If ID was generated by DB, you might use QueryRow(... RETURNING id).Scan(&user.ID)
	return createdUser, nil
}

func (r *UserRepo) Update(ctx context.Context, user *dto.UpdateUserRequest) (*models.User, error) {
	sql := `UPDATE users
             SET name = $1
             WHERE id = $2
             RETURNING id, name, email, created_at, updated_at` // Return all needed fields

	updatedUser := &models.User{}

	err := r.db.QueryRow(ctx, sql, user.Name, user.ID).Scan( // Pass values for SET and WHERE
        &updatedUser.ID,
        &updatedUser.Name,
        &updatedUser.Email,
        &updatedUser.CreatedAt,
        &updatedUser.UpdatedAt, // This will contain the trigger-set value
    )
	if err != nil {
		// Check for unique constraint violation on update (e.g., email)
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" {
			log.Printf("Attempted to update user %s resulting in duplicate email: %v\n", user.ID, err)
			return nil, storage.ErrConflict
		}
		log.Printf("Error updating user %s: %v\n", user.ID, err)
		return nil, err
	}

	return updatedUser, nil
}

func (r *UserRepo) Delete(ctx context.Context, id *dto.DeleteUserRequest) error {
	query := `DELETE FROM users WHERE id = $1;` // Adjust table/column names

	cmdTag, err := r.db.Exec(ctx, query, id.ID)
	if err != nil {
		log.Printf("Error deleting user %s: %v\n", id, err)
		return err
	}

	if cmdTag.RowsAffected() == 0 {
		return storage.ErrNotFound // No user found with that ID
	}

	return nil
}
