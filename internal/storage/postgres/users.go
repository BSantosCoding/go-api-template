package postgres

import (
	"context"
	"errors" // Import errors package
	"log"    // For logging errors

	"go-api-template/internal/models"
	"go-api-template/internal/storage" // Import the interface package

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn" // For checking specific errors
	"github.com/jackc/pgx/v5/pgxpool"
)

// UserRepo implements the storage.UserRepository interface using PostgreSQL.
type UserRepo struct {
	db *pgxpool.Pool
}

// NewUserRepo creates a new UserRepo.
func NewUserRepo(db *pgxpool.Pool) *UserRepo {
	return &UserRepo{db: db}
}

// Compile-time check to ensure UserRepo implements UserRepository
var _ storage.UserRepository = (*UserRepo)(nil)

func (r *UserRepo) GetAll(ctx context.Context) ([]models.User, error) {
	query := `SELECT id, name, email FROM users ORDER BY name ASC;` // Adjust table/column names if needed
	rows, err := r.db.Query(ctx, query)
	if err != nil {
		log.Printf("Error querying all users: %v\n", err)
		return nil, err
	}
	defer rows.Close()

	users, err := pgx.CollectRows(rows, pgx.RowToStructByName[models.User])
	if err != nil {
		log.Printf("Error scanning users: %v\n", err)
		return nil, err
	}

	// Return empty slice instead of nil if no users found
	if users == nil {
		users = []models.User{}
	}

	return users, nil
}

func (r *UserRepo) GetByID(ctx context.Context, id string) (*models.User, error) {
	query := `SELECT id, name, email FROM users WHERE id = $1;` // Adjust table/column names
	row := r.db.QueryRow(ctx, query, id)

	var user models.User
	err := row.Scan(&user.ID, &user.Name, &user.Email)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, storage.ErrNotFound // Use a custom error type later if needed
		}
		log.Printf("Error scanning user by ID %s: %v\n", id, err)
		return nil, err
	}
	return &user, nil
}

func (r *UserRepo) Create(ctx context.Context, user *models.User) error {
	// Assuming ID is generated by the database (e.g., SERIAL or UUID extension)
	// Or if ID is provided (e.g., client-generated UUID)
	// Let's assume ID is provided for this example, matching the model
	query := `INSERT INTO users (id, name, email) VALUES ($1, $2, $3);` // Adjust table/column names

	_, err := r.db.Exec(ctx, query, user.ID, user.Name, user.Email)
	if err != nil {
		// Check for unique constraint violation (example)
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" { // 23505 is unique_violation
			log.Printf("Attempted to create user with duplicate ID or email: %v\n", err)
			return storage.ErrConflict // Use a custom error type later
		}
		log.Printf("Error creating user: %v\n", err)
		return err
	}
	// If ID was generated by DB, you might use QueryRow(... RETURNING id).Scan(&user.ID)
	return nil
}

func (r *UserRepo) Update(ctx context.Context, id string, user *models.User) error {
	query := `UPDATE users SET name = $1, email = $2 WHERE id = $3;` // Adjust table/column names

	cmdTag, err := r.db.Exec(ctx, query, user.Name, user.Email, id)
	if err != nil {
		// Check for unique constraint violation on update (e.g., email)
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) && pgErr.Code == "23505" {
			log.Printf("Attempted to update user %s resulting in duplicate email: %v\n", id, err)
			return storage.ErrConflict
		}
		log.Printf("Error updating user %s: %v\n", id, err)
		return err
	}

	if cmdTag.RowsAffected() == 0 {
		return storage.ErrNotFound // No user found with that ID
	}

	return nil
}

func (r *UserRepo) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM users WHERE id = $1;` // Adjust table/column names

	cmdTag, err := r.db.Exec(ctx, query, id)
	if err != nil {
		log.Printf("Error deleting user %s: %v\n", id, err)
		return err
	}

	if cmdTag.RowsAffected() == 0 {
		return storage.ErrNotFound // No user found with that ID
	}

	return nil
}
